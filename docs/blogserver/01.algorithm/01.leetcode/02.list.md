---
title: 链表
date: 2022-05-21 14:27:21
permalink: /pages/algorithm/leetcode/list
titleTag: 原创
# sticky: 1
categories: 
  - algorithm
  - leetcode
  - list
tags: 
  - algorithm
  - leetcode
  - list
author: 
  name: qinpeng
  link: https://github.com/qinXpeng
---
# 链表题集合
::: cardList
```yaml
- name: leetcode链表
  desc: leetcode一些链表题汇总
  bgColor: '#FCDBA0'
  textColor: '#A05F2C'
- name: 反转链表
  desc: 环形链表
  bgColor: '#CBEAFA'
  textColor: '#6854A1'
- name: k个链表
  desc: 相交链表
  bgColor: '#38d9ae'
  textColor: '#A05F2C'
```
:::
<!-- more -->

## 1.反转链表
::: tip Describe
给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
::: right
[题目链接](https://leetcode.cn/problems/reverse-linked-list/)
:::

::: details Code
<code-group>
  <code-block title="C++" active>
  ```cpp
  /**
  * Definition for singly-linked list.
  * struct ListNode {
  *     int val;
  *     ListNode *next;
  *     ListNode() : val(0), next(nullptr) {}
  *     ListNode(int x) : val(x), next(nullptr) {}
  *     ListNode(int x, ListNode *next) : val(x), next(next) {}
  * };
  */
  class Solution {
  public:
      ListNode* reverseList(ListNode* head) {
          if(head == nullptr){
              return head;
          }
          ListNode *p = nullptr;
          while(head!=nullptr){
              ListNode *q=head;
              head=head->next;
              q->next=p;
              p=q;
          }
          return p;
      }
  };
  ```
  </code-block>

  <code-block title="GO">
  ```go
  func reverseList(head *ListNode) *ListNode {
      if head ==nil{
          return head
      }
      var p *ListNode
      for ;head!=nil;{
          q := head
          head=head.Next
          q.Next = p
          p=q
      }
      return p
  }
  ```
  </code-block>
</code-group>
:::

## 2.合并两个有序链表
::: tip Describe
将两个升序链表合并为一个新的 升序 链表并返回。
::: right
[题目链接](https://leetcode.cn/problems/merge-two-sorted-lists/)
:::

::: details Code
<code-group>
  <code-block title="C++" active>
  ```cpp
  /**
  * Definition for singly-linked list.
  * struct ListNode {
  *     int val;
  *     ListNode *next;
  *     ListNode() : val(0), next(nullptr) {}
  *     ListNode(int x) : val(x), next(nullptr) {}
  *     ListNode(int x, ListNode *next) : val(x), next(next) {}
  * };
  */
  class Solution {
  public:
      ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
          ListNode *newList = new ListNode();
          ListNode *resList = newList;
          while(list1!=NULL && list2 !=NULL){
              if(list1->val <= list2->val){
                  newList->next=list1;
                  list1=list1->next;
              }else{
                  newList->next=list2;
                  list2=list2->next;
              }
              newList=newList->next;
          }
          if(list1!=NULL){
              newList->next=list1;
          }
          if(list2!=NULL){
              newList->next=list2;
          }
          return resList->next;
      }
  };
  ```
  </code-block>

  <code-block title="GO">
  ```go
  /**
  * Definition for singly-linked list.
  * type ListNode struct {
  *     Val int
  *     Next *ListNode
  * }
  */
  func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
      newList := new(ListNode)
      resList := newList
      for ;list1!=nil && list2!=nil;{
          if list1.Val <= list2.Val {
              newList.Next=list1
              list1=list1.Next
          }else{
              newList.Next=list2
              list2=list2.Next
          }
          newList=newList.Next
      }
      if list1!=nil{
          newList.Next=list1
      }
      if list2!=nil{
          newList.Next=list2
      }
      return resList.Next   
  }
  ```
  </code-block>
</code-group>
:::


## 3.k个一组反转链表
::: tip Describe
将链表k个节点一组反转，每次用尾巴连接新的一组反转链表，然后更新尾巴即可。
::: right
[题目链接](https://leetcode.cn/problems/reverse-nodes-in-k-group/)
:::

::: details Code
<code-group>
  <code-block title="C++" active>
  ```cpp
  /**
  * Definition for singly-linked list.
  * struct ListNode {
  *     int val;
  *     ListNode *next;
  *     ListNode() : val(0), next(nullptr) {}
  *     ListNode(int x) : val(x), next(nullptr) {}
  *     ListNode(int x, ListNode *next) : val(x), next(next) {}
  * };
  */
  class Solution {
  public:
      ListNode* felxList(ListNode* &head,int k){
          ListNode* p = NULL;
          ListNode* res = NULL;
          while(head!=NULL && k>0){
              p=head;
              head=head->next;
              p->next=res;
              res=p;
              k--;
          }
          return res;
      }
      int countList(ListNode* head){
          int len=0;
          while(head!=NULL){
              len++;
              head=head->next;
          }
          return len;
      }
      ListNode* reverseKGroup(ListNode* head, int k) {
          if(head==NULL){
              return head;
          }
          int n= countList(head);
          int rotates = n/k;
          ListNode* tail = new ListNode();
          ListNode* ans = tail;
          while(rotates--){
              ListNode* last=head; // 头节点最后是尾巴
              ListNode* resList = felxList(head,k); //反转链表
              tail->next = resList; // 用尾巴连接新的一组反转链表
              tail=last; // 更新尾巴
          }
          tail->next=head; // 更新尾巴
          return ans->next;
      }
  };
  ```
  </code-block>

  <code-block title="GO">
  ```go
  /**
  * Definition for singly-linked list.
  * type ListNode struct {
  *     Val int
  *     Next *ListNode
  * }
  */
  func countList(head *ListNode) int {
      n := 0;
      for ;head!=nil; head=head.Next {
          n++
      }
      return n;
  }
  func flexList(head **ListNode,k int) *ListNode{
      var p *ListNode
      var res *ListNode
      for ;head!=nil && k > 0;{
          p=*head
          *head=(*head).Next
          p.Next=res
          res=p
          k--
      }
      return res
  }
  func reverseKGroup(head *ListNode, k int) *ListNode {
      n := countList(head)
      rotates := n/k
      tail := new(ListNode)
      ans := tail 
      for ;rotates > 0;{
          last := head //记录尾巴
          resList := flexList(&head,k) //反转k个节点
          tail.Next=resList // 用尾巴连接
          tail=last//更新尾巴
          rotates--
      }
      tail.Next=head;//更新尾巴
      return ans.Next;
  }
  ```
  </code-block>
</code-group>
:::