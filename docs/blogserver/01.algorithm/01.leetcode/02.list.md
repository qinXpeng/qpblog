---
title: 链表
date: 2022-05-21 14:27:21
permalink: /pages/algorithm/leetcode/list
titleTag: 原创
# sticky: 1
categories: 
  - algorithm
  - leetcode
  - list
tags: 
  - algorithm
  - leetcode
  - list
author: 
  name: qinpeng
  link: https://github.com/qinXpeng
---
# 链表题集合
::: cardList
```yaml
- name: leetcode链表
  desc: leetcode一些链表题汇总
  bgColor: '#FCDBA0'
  textColor: '#A05F2C'
- name: 反转链表
  desc: 环形链表
  bgColor: '#CBEAFA'
  textColor: '#6854A1'
- name: k个链表
  desc: 相交链表
  bgColor: '#38d9ae'
  textColor: '#A05F2C'
```
:::
<!-- more -->

## 1.反转链表
::: tip Describe
给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
::: right
[题目链接](https://leetcode.cn/problems/reverse-linked-list/)
:::

::: details Code
<code-group>
  <code-block title="C++" active>
  ```cpp
  /**
  * Definition for singly-linked list.
  * struct ListNode {
  *     int val;
  *     ListNode *next;
  *     ListNode() : val(0), next(nullptr) {}
  *     ListNode(int x) : val(x), next(nullptr) {}
  *     ListNode(int x, ListNode *next) : val(x), next(next) {}
  * };
  */
  class Solution {
  public:
      ListNode* reverseList(ListNode* head) {
          if(head == nullptr){
              return head;
          }
          ListNode *p = nullptr;
          while(head!=nullptr){
              ListNode *q=head;
              head=head->next;
              q->next=p;
              p=q;
          }
          return p;
      }
  };
  ```
  </code-block>

  <code-block title="GO">
  ```go
  func reverseList(head *ListNode) *ListNode {
      if head ==nil{
          return head
      }
      var p *ListNode
      for ;head!=nil;{
          q := head
          head=head.Next
          q.Next = p
          p=q
      }
      return p
  }
  ```
  </code-block>
</code-group>
:::

## 2.合并两个有序链表
::: tip Describe
将两个升序链表合并为一个新的 升序 链表并返回。
::: right
[题目链接](https://leetcode.cn/problems/merge-two-sorted-lists/)
:::

::: details Code
<code-group>
  <code-block title="C++" active>
  ```cpp
  /**
  * Definition for singly-linked list.
  * struct ListNode {
  *     int val;
  *     ListNode *next;
  *     ListNode() : val(0), next(nullptr) {}
  *     ListNode(int x) : val(x), next(nullptr) {}
  *     ListNode(int x, ListNode *next) : val(x), next(next) {}
  * };
  */
  class Solution {
  public:
      ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
          ListNode *newList = new ListNode();
          ListNode *resList = newList;
          while(list1!=NULL && list2 !=NULL){
              if(list1->val <= list2->val){
                  newList->next=list1;
                  list1=list1->next;
              }else{
                  newList->next=list2;
                  list2=list2->next;
              }
              newList=newList->next;
          }
          if(list1!=NULL){
              newList->next=list1;
          }
          if(list2!=NULL){
              newList->next=list2;
          }
          return resList->next;
      }
  };
  ```
  </code-block>

  <code-block title="GO">
  ```go
  /**
  * Definition for singly-linked list.
  * type ListNode struct {
  *     Val int
  *     Next *ListNode
  * }
  */
  func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
      newList := new(ListNode)
      resList := newList
      for ;list1!=nil && list2!=nil;{
          if list1.Val <= list2.Val {
              newList.Next=list1
              list1=list1.Next
          }else{
              newList.Next=list2
              list2=list2.Next
          }
          newList=newList.Next
      }
      if list1!=nil{
          newList.Next=list1
      }
      if list2!=nil{
          newList.Next=list2
      }
      return resList.Next   
  }
  ```
  </code-block>
</code-group>
:::


## 3.k个一组反转链表
::: tip Describe
将链表k个节点一组反转，每次用尾巴连接新的一组反转链表，然后更新尾巴即可。
::: right
[题目链接](https://leetcode.cn/problems/reverse-nodes-in-k-group/)
:::

::: details Code
<code-group>
  <code-block title="C++" active>
  ```cpp
  /**
  * Definition for singly-linked list.
  * struct ListNode {
  *     int val;
  *     ListNode *next;
  *     ListNode() : val(0), next(nullptr) {}
  *     ListNode(int x) : val(x), next(nullptr) {}
  *     ListNode(int x, ListNode *next) : val(x), next(next) {}
  * };
  */
  class Solution {
  public:
      ListNode* felxList(ListNode* &head,int k){
          ListNode* p = NULL;
          ListNode* res = NULL;
          while(head!=NULL && k>0){
              p=head;
              head=head->next;
              p->next=res;
              res=p;
              k--;
          }
          return res;
      }
      int countList(ListNode* head){
          int len=0;
          while(head!=NULL){
              len++;
              head=head->next;
          }
          return len;
      }
      ListNode* reverseKGroup(ListNode* head, int k) {
          if(head==NULL){
              return head;
          }
          int n= countList(head);
          int rotates = n/k;
          ListNode* tail = new ListNode();
          ListNode* ans = tail;
          while(rotates--){
              ListNode* last=head; // 头节点最后是尾巴
              ListNode* resList = felxList(head,k); //反转链表
              tail->next = resList; // 用尾巴连接新的一组反转链表
              tail=last; // 更新尾巴
          }
          tail->next=head; // 更新尾巴
          return ans->next;
      }
  };
  ```
  </code-block>

  <code-block title="GO">
  ```go
  /**
  * Definition for singly-linked list.
  * type ListNode struct {
  *     Val int
  *     Next *ListNode
  * }
  */
  func countList(head *ListNode) int {
      n := 0;
      for ;head!=nil; head=head.Next {
          n++
      }
      return n;
  }
  func flexList(head **ListNode,k int) *ListNode{
      var p *ListNode
      var res *ListNode
      for ;head!=nil && k > 0;{
          p=*head
          *head=(*head).Next
          p.Next=res
          res=p
          k--
      }
      return res
  }
  func reverseKGroup(head *ListNode, k int) *ListNode {
      n := countList(head)
      rotates := n/k
      tail := new(ListNode)
      ans := tail 
      for ;rotates > 0;{
          last := head //记录尾巴
          resList := flexList(&head,k) //反转k个节点
          tail.Next=resList // 用尾巴连接
          tail=last//更新尾巴
          rotates--
      }
      tail.Next=head;//更新尾巴
      return ans.Next;
  }
  ```
  </code-block>
</code-group>
:::

## 4.环形链表
::: tip Describe
判断链表中是否有环,并返回节点。
::: right
[题目链接](https://leetcode.cn/problems/linked-list-cycle-ii/)
:::

::: details Code
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func detectCycle(head *ListNode) *ListNode {
    if head == nil {
        return head
    }
    low := head
    fast := head
    for ;fast != nil && fast.Next!=nil;{
        fast=fast.Next.Next
        low=low.Next
        if fast==low{
            for ;head!=low;{
                head=head.Next
                low=low.Next
            }
            return head
        }
    }
    return nil
}
```
:::

## 5.相交链表
::: tip Describe
2个链表找出相交的节点。让2个链表从相同的长度走起，
::: right
[题目链接](https://leetcode.cn/problems/intersection-of-two-linked-lists/)
:::

::: details Code
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    if headA==nil || headB ==nil {
        return nil
    }
    la := headA
    lb:=headB
    for ;la != lb ;{
        if la == nil{
            la = headB
        }else{
            la=la.Next
        }
        if lb == nil{
            lb = headA
        }else{
            lb=lb.Next
        }
    }
    return la
}
```
:::

## 6.反转链表II
::: tip Describe
反转指定区间的链表。
::: right
[题目链接](https://leetcode.cn/problems/reverse-linked-list-ii/)
:::

::: details Code
```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverList(head **ListNode ,k int)*ListNode{
    var pa *ListNode
    var pb *ListNode
    for ;head!=nil&&k>0;{
        pb = *head
        *head=(*head).Next
        pb.Next=pa;
        pa=pb;
        k--
    }
    return pa
}
func reverseBetween(head *ListNode, left int, right int) *ListNode {
    if left==right {
        return head
    }
    res := head
    k := 0
    var last *ListNode
    for ;;{
        k++
        if k ==left{
            tail := head
            reverList := reverList(&head,right-left+1)
            tail.Next=head
            if left == 1 {
                return reverList
            }
            last.Next = reverList
            return res
        }
        last=head
        head=head.Next
    }
    return nil
}
```