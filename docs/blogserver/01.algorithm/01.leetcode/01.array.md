---
title: 数组
date: 2022-05-21 14:27:21
permalink: /pages/algorithm/leetcode/array
titleTag: 原创
# sticky: 1
categories: 
  - algorithm
  - leetcode
  - array
tags: 
  - algorithm
  - leetcode
  - array
author: 
  name: qinpeng
  link: https://github.com/qinXpeng
---

一些简单的leetcode数组,eazy
<!-- more -->

## 生成数组

$\sum_{i=1}^{n}i*\mu(i)$


设dp[i][j][k]表示 数组的第 i位 最大值是j且比较次数是 k 的方法数
那么其中一个就是 第i-1位，最大值在[1,j-1]且比较次数是k-1，
即dp[i-1][1,j-1][k-1]转移过来的。
还有一种情况是第i-1位的最大值也是j,那么第i位可以选择的数字肯定是[1,j],
所以转移的方程是 dp[i-1][j][k]*j

*****

::: tip
dp算法
:::

<code-group>
  <code-block title="go" active>
```go
int dp[505][505];
int minInsertions(string s) {
    int n=s.size();
    for(int i=1;i<=n;i++){// dp[i][j]区间[i,j]的最长回文子序列。
        dp[i][i]=1;
        for(int j=i-1;j>=1;j--){
            if(s[i-1]==s[j-1])dp[j][i]=dp[j+1][i-1]+2;
            else dp[j][i]=max(dp[j+1][i],dp[j][i-1]);
        }
    }
    return n-dp[1][n];
}
```
</code-block>

<code-block title="cpp">
```cpp
const mod int64 = 1000000007
func numOfArrays(n int, m int, w int) int {
    if w==0{
        return 0;
    }
    var dp [55][105][55]int64
    for i:=1;i<=m;i++{
        dp[1][i][1]=1;
    }
    for i:=2;i<=n;i++{
        for j:=1;j<=m;j++{
            for k:=1;k<=w;k++{
                for l:=1;l<j;l++{
                    dp[i][j][k]+=dp[i-1][l][k-1]
                    dp[i][j][k]%=mod
                }
                dp[i][j][k]+=dp[i-1][j][k]*(int64(j))%mod
                dp[i][j][k]%=mod
            }
        }
    }
    var ans int64 =0
    for i:=1;i<=m;i++{
        ans+=dp[n][i][w]
        ans%=mod
    }
    return (int)(ans)
}
```
</code-block>
</code-group>
