---
title: leetcode数组
date: 2022-05-21 14:27:21
permalink: /pages/algorithm/leetcode/array
titleTag: 原创
sticky: 1
sidebar: auto
data:
    description:leetcode数组类型
categories: 
  - algorithm
  - leetcode
tags: 
  - algorithm
  - leetcode
author: 
  name: qinpeng
  link: https://github.com/qinXpeng
---

# leetcode数组

## 生成数组

$\sum_{i=1}^{n}i*\mu(i)$

<p>Pythagoran theorem is <math><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo><msup><mi>b</mi><mn>2</mn></msup><mo>=</mo><msup><mi>c</mi><mn>2</mn></msup></math>.</p>
<p>Bayes theorem:</p>
<math display="block"><mi>P</mi><mfenced open="(" close=")"><mrow><mi>A</mi><mo stretchy="true" lspace="veryverythickmathspace" rspace="veryverythickmathspace">|</mo><mi>B</mi></mrow></mfenced><mo>=</mo><mfrac><mrow><mi>P</mi><mfenced open="(" close=")"><mrow><mi>B</mi><mo stretchy="true" lspace="veryverythickmathspace" rspace="veryverythickmathspace">|</mo><mi>A</mi></mrow></mfenced><mi>P</mi><mfenced open="(" close=")"><mi>A</mi></mfenced></mrow><mrow><mi>P</mi><mfenced open="(" close=")"><mi>B</mi></mfenced></mrow></mfrac></math>

设dp[i][j][k]表示 数组的第 i位 最大值是j且比较次数是 k 的方法数
那么其中一个就是 第i-1位，最大值在[1,j-1]且比较次数是k-1，
即dp[i-1][1,j-1][k-1]转移过来的。
还有一种情况是第i-1位的最大值也是j,那么第i位可以选择的数字肯定是[1,j],
所以转移的方程是 dp[i-1][j][k]*j
<!-- more -->
*****

::: tip
dp算法
:::
<code-group>
  <code-block title="go" active>
```go
const mod int64 = 1000000007
func numOfArrays(n int, m int, w int) int {
    if w==0{
        return 0;
    }
    var dp [55][105][55]int64
    for i:=1;i<=m;i++{
        dp[1][i][1]=1;
    }
    for i:=2;i<=n;i++{
        for j:=1;j<=m;j++{
            for k:=1;k<=w;k++{
                for l:=1;l<j;l++{
                    dp[i][j][k]+=dp[i-1][l][k-1]
                    dp[i][j][k]%=mod
                }
                dp[i][j][k]+=dp[i-1][j][k]*(int64(j))%mod
                dp[i][j][k]%=mod
            }
        }
    }
    var ans int64 =0
    for i:=1;i<=m;i++{
        ans+=dp[n][i][w]
        ans%=mod
    }
    return (int)(ans)
}
```
  </code-block>

  <code-block title="cpp">
```cpp
const mod int64 = 1000000007
func numOfArrays(n int, m int, w int) int {
    if w==0{
        return 0;
    }
    var dp [55][105][55]int64
    for i:=1;i<=m;i++{
        dp[1][i][1]=1;
    }
    for i:=2;i<=n;i++{
        for j:=1;j<=m;j++{
            for k:=1;k<=w;k++{
                for l:=1;l<j;l++{
                    dp[i][j][k]+=dp[i-1][l][k-1]
                    dp[i][j][k]%=mod
                }
                dp[i][j][k]+=dp[i-1][j][k]*(int64(j))%mod
                dp[i][j][k]%=mod
            }
        }
    }
    var ans int64 =0
    for i:=1;i<=m;i++{
        ans+=dp[n][i][w]
        ans%=mod
    }
    return (int)(ans)
}
```
</code-block>
</code-group>
